Index: src/main/java/pcd/part2/vertX/CrawlerVertX.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package pcd.part2.vertX;\r\n\r\nimport io.vertx.core.DeploymentOptions;\r\nimport io.vertx.core.Vertx;\r\nimport pcd.part2.Report;\r\nimport java.util.HashMap;\r\nimport java.util.regex.Pattern;\r\n\r\n\r\npublic class CrawlerVertX {\r\n    public static Report getWordOccurrences (String entryPoint, String word, int depth) throws InterruptedException {\r\n        HashMap<String, Integer> result = new HashMap<>();\r\n        Flag flag = new Flag();\r\n        /*\r\n        Un’applicazione Vert.x consiste di uno o più componenti chiamati Verticle. questi sono pezzi di\r\n        codice che il motore di Vert.x esegue.\r\n        Ogni verticle viene eseguito in maniera concorrente rispetto agli altri e non c’è uno stato che viene condiviso.\r\n        Tradotto in parole semplici, si riesce a creare applicazioni multi-threaded senza dover gestire problematiche\r\n        di concorrenza come la sincronizzazione o i lock tra thread.\r\n        * */\r\n        String regex = \"\\\\b(?<=(href=\\\"))[^\\\"]*?(?=\\\")\";\r\n        Pattern pattern = Pattern.compile(regex);\r\n        Vertx vertx = Vertx.vertx();\r\n\r\n        CountWordVerticle verticle = new CountWordVerticle(entryPoint, word, depth,result,pattern,flag);\r\n        vertx.deployVerticle(verticle);\r\n        while(!flag.isSet()){\r\n         System.out.println(\"im waiting\");\r\n        }\r\n\r\n        return new Report(word, result);\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/pcd/part2/vertX/CrawlerVertX.java b/src/main/java/pcd/part2/vertX/CrawlerVertX.java
--- a/src/main/java/pcd/part2/vertX/CrawlerVertX.java	
+++ b/src/main/java/pcd/part2/vertX/CrawlerVertX.java	
@@ -25,7 +25,7 @@
         CountWordVerticle verticle = new CountWordVerticle(entryPoint, word, depth,result,pattern,flag);
         vertx.deployVerticle(verticle);
         while(!flag.isSet()){
-         System.out.println("im waiting");
+
         }
 
         return new Report(word, result);
Index: src/main/java/pcd/part2/Main.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package pcd.part2;\r\n\r\nimport pcd.part2.vertX.CrawlerVertX;\r\nimport pcd.part2.virtualThread.CrawlerVT;\r\n\r\nimport java.io.IOException;\r\n\r\npublic class Main {\r\n\r\n    public static void main(String[] args) throws IOException, InterruptedException {\r\n        String URL = \"https://finagricola.it/il-fresco/pomodori/pomodoro-ciliegino/\";\r\n        String wordToFind = \"pomodoro\";\r\n        //depth = 0 to analyze only entrypoint page\r\n        //depth = 2 ti bloccano\r\n        int depth = 0;\r\n\r\n        long startTime = System.currentTimeMillis();\r\n\r\n        //Report report  = RecursiveCounter.getWordOccurrences(URL, wordToFind, depth);\r\n        //Report report  = CrawlerVT.getWordOccurrences(URL, wordToFind, depth);\r\n        Report report = CrawlerVertX.getWordOccurrences(URL, wordToFind, depth);\r\n\r\n        System.out.println(\"[TIME OF EXECUTION] : \" + (System.currentTimeMillis()-startTime) + \"Milliseconds\");\r\n\r\n        //Decomment to get a report.txt\r\n        //report.getTxtReport();\r\n        report.logResult();\r\n\r\n\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/pcd/part2/Main.java b/src/main/java/pcd/part2/Main.java
--- a/src/main/java/pcd/part2/Main.java	
+++ b/src/main/java/pcd/part2/Main.java	
@@ -8,8 +8,8 @@
 public class Main {
 
     public static void main(String[] args) throws IOException, InterruptedException {
-        String URL = "https://finagricola.it/il-fresco/pomodori/pomodoro-ciliegino/";
-        String wordToFind = "pomodoro";
+        String URL = "https://www.orsiniimballaggi.com/";
+        String wordToFind = "il";
         //depth = 0 to analyze only entrypoint page
         //depth = 2 ti bloccano
         int depth = 0;
